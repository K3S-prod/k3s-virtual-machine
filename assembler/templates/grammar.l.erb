%{
#include <cstdio>
#include <assembler/assembler.h>

#define YYDEBUG 1

extern "C" FILE *yyin;
extern "C" int yylex (void);

extern size_t ASM_LINE_NO;

void yyerror(const char *s)
{
    fprintf(stderr, "(line_no:%lu): error: %s\n", ASM_LINE_NO, s);
}

%}

/* declare tokens */
%token REG
%token IMM
%token SPACE
%token B_BEGIN
%token B_END

<% ISA.opcode_signatures.each do |signature| -%>
%token <%= signature.upcase + " " %>
<%- end -%>

%%

program:
    function |
    program function |
    %empty;

function:
    B_BEGIN instructions B_END;

instructions:
    instruction instructions |
    instruction;

instruction:
<% ISA.opcode_signatures.each_with_index do |signature, idx| -%>
    <%- args = ISA.tokenize_signature(signature) -%>
    <%= args["types"].prepend(signature.upcase).join(" ") -%> {
        k3s::ENCODER.Encode<<%=  args["sizes"].prepend("8").join(", ") %>>(<%=  ISA.GetGrammarArgs(args["types"].length).join(", ") %>);
    } <%= ((idx != ISA.opcode_signatures.length - 1) ? "|" : ";") %>
<%- end -%>

%%

namespace k3s {

AsmEncoder ENCODER;

int AsmEncoder::Process(FILE *file)
{
    yydebug = 0;
    yyin = file;
    return yyparse();
}

} // namespace k3s
