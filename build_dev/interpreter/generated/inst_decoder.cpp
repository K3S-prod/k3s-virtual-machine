// AUTOGENERATED FILE

#include "generated/inst_decoder.h"
#include "interpreter/interpreter.h"
#include "common/macro.h"

namespace k3s {

    size_t InstDecoder::DecodeAndResolve(const BytecodeInstruction &inst, const Interpreter &interp)
    {
        size_t opc_overload_prefix = INVALID_OVERLOAD_IDX;

        using Type = Register::Type;
        switch (inst.GetOpcode()) {
            // Controlflow
                // opc_i8
                case Opcode::JUMP:
                {
                    immediate_operand_ = inst.GetOperands() & IMM_MASK;
                    opc_overload_prefix = 0;    
                    break;
                }

                // opc_i8
                case Opcode::BLE:
                {
                    immediate_operand_ = inst.GetOperands() & IMM_MASK;
                    if (interp.CheckRegsTypeWithAcc<Type::NUM>(  )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

                // opc
                case Opcode::CALL:
                {
                    if (interp.CheckRegsTypeWithAcc<Type::FUNC>(  )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

                // opc
                case Opcode::RET:
                {
                    opc_overload_prefix = 0;    
                    break;
                }

            // Objects
                // opc_i8
                case Opcode::LDAI:
                {
                    immediate_operand_ = inst.GetOperands() & IMM_MASK;
                    opc_overload_prefix = 0;    
                    break;
                }

            // DataFlow
                // opc_r8
                case Opcode::LDA:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    if (interp.CheckRegsType<Type::ANY>( register_operands_idx_[0]))  {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

                // opc_r8
                case Opcode::STA:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    if (interp.CheckRegsType<Type::ANY>( register_operands_idx_[0]))  {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

                // opc_r4_r4
                case Opcode::MOV:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    if (interp.CheckRegsType<Type::ANY, Type::ANY>( register_operands_idx_[0], register_operands_idx_[1]))  {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

            // Arithmetic (two-op)
                // opc_r4_r4
                case Opcode::ADD:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    if (interp.CheckRegsType<Type::NUM, Type::NUM>( register_operands_idx_[0], register_operands_idx_[1]))  {
                        opc_overload_prefix = 0;
                        break;
                    }
                    if (interp.CheckRegsType<Type::STR, Type::STR>( register_operands_idx_[0], register_operands_idx_[1]))  {
                        opc_overload_prefix = 1;
                        break;
                    }
                    break;
                }

                // opc_r4_r4
                case Opcode::SUB:
                case Opcode::DIV:
                case Opcode::MUL:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    if (interp.CheckRegsType<Type::NUM, Type::NUM>( register_operands_idx_[0], register_operands_idx_[1]))  {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

            // Arithmetic (single-op)
                // opc_r8
                case Opcode::ADD2:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    if (interp.CheckRegsTypeWithAcc<Type::NUM, Type::NUM>( register_operands_idx_[1] )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    if (interp.CheckRegsTypeWithAcc<Type::STR, Type::STR>( register_operands_idx_[1] )) {
                        opc_overload_prefix = 1;
                        break;
                    }
                    if (interp.CheckRegsTypeWithAcc<Type::ARR, Type::NUM>( register_operands_idx_[1] )) {
                        opc_overload_prefix = 2;
                        break;
                    }
                    break;
                }

                // opc_r8
                case Opcode::SUB2:
                case Opcode::DIV2:
                case Opcode::MUL2:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    if (interp.CheckRegsTypeWithAcc<Type::NUM, Type::NUM>( register_operands_idx_[1] )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    if (interp.CheckRegsTypeWithAcc<Type::ARR, Type::NUM>( register_operands_idx_[1] )) {
                        opc_overload_prefix = 1;
                        break;
                    }
                    break;
                }

            // Arithmetic (zero-op)
                // opc
                case Opcode::DECA:
                {
                    if (interp.CheckRegsTypeWithAcc<Type::NUM>(  )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

            // Array-specific
                // opc_r8
                case Opcode::NEWARR:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    if (interp.CheckRegsType<Type::NUM>( register_operands_idx_[0]))  {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

                // opc_r4_r4
                case Opcode::SETELEM:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    if (interp.CheckRegsTypeWithAcc<Type::ARR, Type::NUM, Type::ANY>( register_operands_idx_[1], register_operands_idx_[2] )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

                // opc_r4_r4
                case Opcode::GETELEM:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    if (interp.CheckRegsTypeWithAcc<Type::ARR, Type::NUM, Type::ANY>( register_operands_idx_[1], register_operands_idx_[2] )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

            // Dump
                // opc_r8
                case Opcode::DUMP:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    if (interp.CheckRegsType<Type::ANY>( register_operands_idx_[0]))  {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

                // opc
                case Opcode::DUMPA:
                {
                    if (interp.CheckRegsTypeWithAcc<Type::ANY>(  )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

            // Function-specific
                // opc_r8
                case Opcode::GETARG0:
                case Opcode::SETRET0:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    if (interp.CheckRegsType<Type::ANY>( register_operands_idx_[0]))  {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

                // opc_r8
                case Opcode::SETARG0:
                case Opcode::GETRET0:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    if (interp.CheckRegsTypeWithAcc<Type::FUNC, Type::ANY>( register_operands_idx_[1] )) {
                        opc_overload_prefix = 0;
                        break;
                    }
                    break;
                }

        }
        if (opc_overload_prefix == INVALID_OVERLOAD_IDX) {
            LOG_FATAL(DECODER, "Can't resolve overload for " << inst);
        }
        
        ASSERT(opc_overload_prefix < (1U << MAX_OPC_OVERLOAD_SIZE_BITS));
        size_t dispatch_idx = (static_cast<size_t>(inst.GetOpcode()) << MAX_OPC_OVERLOAD_SIZE_BITS) | opc_overload_prefix;
        return dispatch_idx;
    }

    Opcode InstDecoder::Decode(const BytecodeInstruction &inst)
    {
        switch (inst.GetOpcode()) {
            // Controlflow
                // {"signature"=>"opc_i8", "opc"=>["jump"], "overloads"=>[{"in"=>[], "out"=>[], "semantics"=>"pc <- pc + i8"}]}
                // opc_i8
                case Opcode::JUMP:
                {
                    break;
                }
                // {"signature"=>"opc_i8", "opc"=>["ble"], "overloads"=>[{"in"=>["a:NUM"], "out"=>[], "semantics"=>"if (acc < 0) { pc <- pc + i8 }"}]}
                // opc_i8
                case Opcode::BLE:
                {
                    break;
                }
                // {"signature"=>"opc", "opc"=>["call"], "overloads"=>[{"in"=>["a:FUNC"], "out"=>[], "semantics"=>"acc.invoke()"}]}
                // opc
                case Opcode::CALL:
                {
                    break;
                }
                // {"signature"=>"opc", "opc"=>["ret"], "overloads"=>[{"in"=>[], "out"=>[], "semantics"=>"return"}]}
                // opc
                case Opcode::RET:
                {
                    break;
                }
            // Objects
                // {"signature"=>"opc_i8", "opc"=>["ldai"], "overloads"=>[{"in"=>[], "out"=>["a:ANY"], "semantics"=>"acc <- allocobj(CONSTANT_POOL[imm8])\n"}]}
                // opc_i8
                case Opcode::LDAI:
                {
                    break;
                }
            // DataFlow
                // {"signature"=>"opc_r8", "opc"=>["lda"], "overloads"=>[{"in"=>["r:ANY"], "out"=>["a:ANY"], "semantics"=>"acc <- reg"}]}
                // opc_r8
                case Opcode::LDA:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    break;
                }
                // {"signature"=>"opc_r8", "opc"=>["sta"], "overloads"=>[{"in"=>["r:ANY"], "out"=>["r:ANY"], "semantics"=>"reg <- acc"}]}
                // opc_r8
                case Opcode::STA:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    break;
                }
                // {"signature"=>"opc_r4_r4", "opc"=>["mov"], "overloads"=>[{"in"=>["r:ANY", "r:ANY"], "out"=>["r:ANY"], "semantics"=>"reg2 <- reg1"}]}
                // opc_r4_r4
                case Opcode::MOV:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    break;
                }
            // Arithmetic (two-op)
                // {"signature"=>"opc_r4_r4", "opc"=>["add"], "overloads"=>[{"in"=>["r:NUM", "r:NUM"], "out"=>["a:NUM"], "semantics"=>"acc <- r0 add r1;"}, {"in"=>["r:STR", "r:STR"], "out"=>["a:STR"], "semantics"=>"a <- concat(r0, r1);"}]}
                // opc_r4_r4
                case Opcode::ADD:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    break;
                }
                // {"signature"=>"opc_r4_r4", "opc"=>["sub", "div", "mul"], "overloads"=>[{"in"=>["r:NUM", "r:NUM"], "out"=>["a:NUM"], "semantics"=>"acc <- r0 opc r1;"}]}
                // opc_r4_r4
                case Opcode::SUB:
                case Opcode::DIV:
                case Opcode::MUL:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    break;
                }
            // Arithmetic (single-op)
                // {"signature"=>"opc_r8", "opc"=>["add2"], "overloads"=>[{"in"=>["a:NUM", "r:NUM"], "out"=>["a:NUM"], "semantics"=>"acc <- acc opc r0"}, {"in"=>["a:STR", "r:STR"], "out"=>["a:STR"], "semantics"=>"acc <- concat(acc, r0)"}, {"in"=>["a:ARR", "r:NUM"], "out"=>["a:ARR"], "semantics"=>"foreach idx { acc[idx] <- acc[idx] opc ri }"}]}
                // opc_r8
                case Opcode::ADD2:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    break;
                }
                // {"signature"=>"opc_r8", "opc"=>["sub2", "div2", "mul2"], "overloads"=>[{"in"=>["a:NUM", "r:NUM"], "out"=>["a:NUM"], "semantics"=>"acc <- acc opc r0"}, {"in"=>["a:ARR", "r:NUM"], "out"=>["a:ARR"], "semantics"=>"foreach idx { acc[idx] <- acc[idx] opc ri }"}]}
                // opc_r8
                case Opcode::SUB2:
                case Opcode::DIV2:
                case Opcode::MUL2:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    break;
                }
            // Arithmetic (zero-op)
                // {"signature"=>"opc", "opc"=>["deca"], "overloads"=>[{"in"=>["a:NUM"], "out"=>["a:NUM"], "semantics"=>"acc--"}]}
                // opc
                case Opcode::DECA:
                {
                    break;
                }
            // Array-specific
                // {"signature"=>"opc_r8", "opc"=>["newarr"], "overloads"=>[{"in"=>["r:NUM"], "out"=>["a:ARR"], "semantics"=>"acc <- allocate_array_with_size(ri)\n"}]}
                // opc_r8
                case Opcode::NEWARR:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    break;
                }
                // {"signature"=>"opc_r4_r4", "opc"=>["setelem"], "overloads"=>[{"in"=>["a:ARR", "r:NUM", "r:ANY"], "out"=>["a:ARR"], "semantics"=>"acc[r1] = r2; acc <- acc;\n"}]}
                // opc_r4_r4
                case Opcode::SETELEM:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    break;
                }
                // {"signature"=>"opc_r4_r4", "opc"=>["getelem"], "overloads"=>[{"in"=>["a:ARR", "r:NUM", "r:ANY"], "out"=>["r:ARR"], "semantics"=>"r2 <- acc[r1];\n"}]}
                // opc_r4_r4
                case Opcode::GETELEM:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_NEAR_REG_MASK;
                    register_operands_idx_[1] = (inst.GetOperands() & SECOND_NEAR_REG_MASK) >> SECOND_NEAR_REG_SHIFT;
                    break;
                }
            // Dump
                // {"signature"=>"opc_r8", "opc"=>["dump"], "overloads"=>[{"in"=>["r:ANY"], "out"=>[], "semantics"=>"r1.dump()"}]}
                // opc_r8
                case Opcode::DUMP:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    break;
                }
                // {"signature"=>"opc", "opc"=>["dumpa"], "overloads"=>[{"in"=>["a:ANY"], "out"=>[], "semantics"=>"acc.dump()"}]}
                // opc
                case Opcode::DUMPA:
                {
                    break;
                }
            // Function-specific
                // {"signature"=>"opc_r8", "opc"=>["getarg0", "setret0"], "overloads"=>[{"in"=>["r:ANY"], "out"=>["r:ANY"], "semantics"=>"1. reg <- (*this).GetArg<0>(); 2. (*this).SetRet<0>(reg);\n"}]}
                // opc_r8
                case Opcode::GETARG0:
                case Opcode::SETRET0:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    break;
                }
                // {"signature"=>"opc_r8", "opc"=>["setarg0", "getret0"], "overloads"=>[{"in"=>["a:FUNC", "r:ANY"], "out"=>[], "semantics"=>"1. acc.GetAsFunction().SetArg<0>(reg) 2. reg <- acc.GetAsFunction().GetRet<0>()\n"}]}
                // opc_r8
                case Opcode::SETARG0:
                case Opcode::GETRET0:
                {
                    register_operands_idx_[0] = inst.GetOperands() & FIRST_FAR_REG_MASK;
                    break;
                }
        }
        return inst.GetOpcode();
    }

}
