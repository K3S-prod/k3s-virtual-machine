###
#   %isa description%
#
###

reg_types:
    - typename: NUM
      desc:     Type to represent real and integer values.

    - typename: ARR
      desc:     Type to represent arrays of elements of any types.

    - typename: STR
      desc:     Type to represent strings.

    - typename: OBJ
      desc:     Type to represent objects with named fields. 
                Each field must have a type and object's layout can't be modified at runtime.
                Store reg to field of different type is a run-time error.

    - typename: FUNC
      desc:     Type to represent functions as objects.
                Registers of such type can be "invoked".
    
    - typename: NIL
      desc:     Empty/undefined value.
    
    - typename: ANY
      desc:     Unspecified type.

signatures:
  - opc_r4_r4
  - opc_r8
  - opc_i8
  - opc

opcodes:
    description:
        Each element of 'groups' should define signature, array of opcodes (mnemonics, related to the 'group') and array of overloads.
        Each overload should be annotated with pseudo-code and define requirements on inputs and guarantees for outputs.
      	Signature describes bit-representation of instructions.
      	Currently, all the opcodes are 8-bit wide and all valid instructions are 16-bit wide.
    opcode_overload_limit:
        4
    groups:
        Controlflow:
            - signature: opc_i8
              opc:
                - jump
              overloads:
                - in: []
                  out: []
                  semantics: pc <- pc + i8
            - signature: opc
              opc:
                - call
              overloads:
                - in: [a:FUNC]
                  out: []
                  semantics: acc.invoke()
            - signature: opc
              opc:
                - ret
              overloads:
                - in: []
                  out: []
                  semantics: return

        Objects:
            - signature: opc_i8
              opc:
                - ldai
              overloads:
                - in: []
                  out: [a:ANY]
                  semantics: > 
                       acc <- allocobj(CONSTANT_POOL[imm8])
        DataFlow:
            - signature: opc_r8
              opc:
                - lda
              overloads:
                - in: [r:ANY]
                  out: [a:ANY]
                  semantics: acc <- reg
            - signature: opc_r8
              opc:
                - sta
              overloads:
                - in: [r:ANY]
                  out: [r:ANY]
                  semantics: reg <- acc

        Arithmetic (two-op):
            - signature: opc_r4_r4
              opc:
                - add
              overloads:
                - in: [r:NUM, r:NUM]
                  out: [a:NUM]
                  semantics: acc <- r0 add r1;
                - in: [r:STR, r:STR]
                  out: [a:STR]
                  semantics: a <- concat(r0, r1);

            - signature: opc_r4_r4
              opc:
                - sub
                - div
                - mul
              overloads:
                - in: [r:NUM, r:NUM]
                  out: [a:NUM]
                  semantics: acc <- r0 opc r1;
                         
        Arithmetic (single-op):
            - signature: opc_r8
              opc:
                - add2
              overloads:
                - in:   [a:NUM, r:NUM]
                  out:  [a:NUM]
                  semantics: acc <- acc opc r0
                - in:   [a:STR, r:STR]
                  out:  [a:STR]
                  semantics: acc <- concat(acc, r0)
                - in:   [a:ARR, r:NUM]
                  out:  [a:ARR]
                  semantics: foreach idx { acc[idx] <- acc[idx] opc ri }

            - signature: opc_r8
              opc:
                - sub2
                - div2
                - mul2
              overloads:
                - in:   [a:NUM, r:NUM]
                  out:  [a:NUM]
                  semantics: acc <- acc opc r0
                - in:   [a:ARR, r:NUM]
                  out:  [a:ARR]
                  semantics: foreach idx { acc[idx] <- acc[idx] opc ri }

        Array-specific:
            - signature: opc_r8
              opc:
                - newarr
              overloads:
                - in: [r:NUM]
                  out: [a:ARR]
                  semantics: > 
                       acc <- allocate_array_with_size(ri)

            - signature: opc_r4_r4
              opc:
                - setelem
              overloads:
                - in: [a:ARR, r:NUM, r:ANY]
                  out: [a:ARR]
                  semantics: >
                       acc[r1] = r2;
                       acc <- acc;

            - signature: opc_r4_r4
              opc:
                - getelem
              overloads:
                - in: [a:ARR, r:NUM, r:ANY]
                  out: [r:ARR]
                  semantics: >
                       r2 <- acc[r1];
        Dump:
            - signature: opc_r8
              opc:
                  - dump
              overloads:
                - in: [r:ANY]
                  out: []
                  semantics: >
                       r1.dump()
                - in: [a:ANY]
                  out: []
                  semantics: >
                       acc.dump()
